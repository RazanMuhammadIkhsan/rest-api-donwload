const axios = require("axios");
const WebSockets = require("ws");
const cheerio = require("cheerio");
const FormDatas = require("form-data");
const fakeUserAgent = require("fake-useragent");
const { fromBuffer } = import("file-type");
const MathRandoms = require("./lib/math.random.cjs");
const { randomUUID } = require("crypto");
const { wrapper } = require("axios-cookiejar-support");
const tough = require("tough-cookie");
const https = require("https");

const ai = {
  ss2code: async (urlImage, timeoutMs = 30000) => {
    function generateUUIDv4() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16) | 0;
        const v = c === "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      });
    }
    const buffer = await axios.get(urlImage, { responseType: "arraybuffer" });
    const base64 = `data:image/png;base64,${Buffer.from(buffer.data).toString("base64")}`;
    const uuid = generateUUIDv4();

    return new Promise((resolve, reject) => {
      const sock = new WebSockets(
        "wss://screenshot-code.onrender.com/generate-code",
      );

      const timer = setTimeout(() => {
        sock.terminate();
        reject(new Error("Timeout: Server tidak merespons dalam 30 detik"));
      }, timeoutMs);

      sock.on("open", () => {
        const payload = {
          generationType: "create",
          image: base64,
          codeGenerationModel: "gpt-4o-2024-05-13",
          editorTheme: "cobalt",
          generatedCodeConfig: "html_tailwind",
          inputMode: "image",
          isImageGenerationEnabled: true,
          isTermOfServiceAccepted: false,
          openAiApiKey: null,
          openAiBaseURL: null,
          screenshotOneApiKey: null,
          sessionId: uuid,
        };
        sock.send(JSON.stringify(payload));
      });

      sock.on("message", (raw) => {
        try {
          const data = JSON.parse(raw.toString());
          if (data.type === "setCode") {
            clearTimeout(timer);
            sock.close();
            resolve({ code: data.value });
          }
        } catch (err) {
          clearTimeout(timer);
          sock.close();
          reject(new Error("Parsing error: " + err.message));
        }
      });

      sock.on("error", (err) => {
        clearTimeout(timer);
        reject(err);
      });

      sock.on("close", () => {
        console.log("WebSockets Closed!");
      });
    });
  },
  chatAIOrg: async (query) => {
    if (!query) {
      return {
        code: 403,
        timestamp: new Date().getTime(),
        message: "Query Tidak Di Isi!",
      };
    }
    let payload = {
      messages: [
        {
          role: "user",
          content: query,
        },
      ],
    };
    let headers = {
      headers: {
        Origin: "https://chatai.org",
        Referer: "https://chatai.org/",
      },
    };
    let { data } = await axios.post(
      "https://chatai.org/api/chat",
      payload,
      headers,
    );
    if (data.status === 500) {
      return {
        code: 500,
        timestamp: new Date().getTime(),
        message: data.data || null,
      };
    }
    return {
      code: 200,
      timestamp: new Date().getTime(),
      message: data.content,
    };
  },
  chatAIOrgPrompt: async (query, prompt) => {
    if (!query && !prompt) {
      return {
        code: 403,
        timestamp: new Date().getTime(),
        message: "Parameter Query Atau Prompt Tidak Terisi.",
      };
    }
    let payload = {
      messages: [
        {
          role: "user",
          content: "Siapa Nama Kamu?",
        },
        {
          role: "assistant",
          content: prompt,
        },
        {
          role: "user",
          content: query,
        },
      ],
    };
    let headers = {
      headers: {
        Origin: "https://chatai.org",
        Referer: "https://chatai.org/",
      },
    };
    let { data } = await axios.post(
      "https://chatai.org/api/chat",
      payload,
      headers,
    );
    if (data.status === 500) {
      return {
        code: 500,
        timestamp: new Date().getTime(),
        message: data.data || null,
      };
    }
    return {
      code: 200,
      timestamp: new Date().getTime(),
      content: data.content,
    };
  },
  gptOnline: async (prompt) => {
    const { data: html } = await axios.get(
      "https://gptonline.ai/id/chatgpt-online/",
    );
    const $ = cheerio.load(html);

    const div = $(".wpaicg-chat-shortcode");
    const nonce = div.attr("data-nonce");
    const botId = div.attr("data-bot-id");
    const postId = div.attr("data-post-id");

    const form = new FormDatas();
    form.append("_wpnonce", nonce);
    form.append("post_id", postId);
    form.append("url", "https://gptonline.ai/id/chatgpt-online/");
    form.append("action", "wpaicg_chat_shortcode_message");
    form.append("message", prompt);
    form.append("bot_id", botId);
    form.append("chat_bot_identity", "custom_bot_1040");
    form.append("wpaicg_chat_history", "[]");
    form.append("wpaicg_chat_client_id", "LCgGOMeIOC");

    const headersList = {
      headers: {
        ...form.getHeaders(),
      },
    };

    const { data } = await axios.post(
      "https://gptonline.ai/id/wp-admin/admin-ajax.php",
      form,
      headersList,
    );
    return data;
  },
  aiCodeAssistant: async (q) => {
    async function generateUserId() {
      const chars =
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      let userId = "";
      for (let i = 0; i < 10; i++) {
        userId += chars[Math.floor(Math.random() * chars.length)];
      }
      return userId;
    }
    let userId = await generateUserId();
    let { data } = await axios.get(
      `https://yw85opafq6.execute-api.us-east-1.amazonaws.com/default/boss_mode_15aug?text=Generate a Codes in Indonesian for the following text: ${encodeURIComponent(q)}&country=Asia&user_id=${userId}`,
    );
    return data;
  },
  toBald: async (imgUrl) => {
    const ress = await axios.get(imgUrl, {
      responseType: "arraybuffer",
    });
    const base64 = Buffer.from(ress.data).toString("base64");
    const payload = {
      filter: "botak",
      imageData: base64,
    };
    const { data } = await axios.post(
      "https://wpw.my.id/api/process-image",
      payload,
    );
    return {
      success: true,
      outputBase64: data.processedImageUrl,
    };
  },
  toBlack: async (imgUrl) => {
    const ress = await axios.get(imgUrl, {
      responseType: "arraybuffer",
    });
    const base64 = Buffer.from(ress.data).toString("base64");
    const payload = {
      filter: "hitam",
      imageData: base64,
    };
    const { data } = await axios.post(
      "https://wpw.my.id/api/process-image",
      payload,
    );
    return {
      success: true,
      outputBase64: data.processedImageUrl,
    };
  },
  toPiggy: async (imgUrl) => {
    const ress = await axios.get(imgUrl, {
      responseType: "arraybuffer",
    });
    const base64 = Buffer.from(ress.data).toString("base64");
    const payload = {
      filter: "piggy",
      imageData: base64,
    };
    const { data } = await axios.post(
      "https://wpw.my.id/api/process-image",
      payload,
    );
    return {
      success: true,
      outputBase64: data.processedImageUrl,
    };
  },
  toNerd: async (imgUrl) => {
    const ress = await axios.get(imgUrl, {
      responseType: "arraybuffer",
    });
    const base64 = Buffer.from(ress.data).toString("base64");
    const payload = {
      filter: "nerd",
      imageData: base64,
    };
    const { data } = await axios.post(
      "https://wpw.my.id/api/process-image",
      payload,
    );
    return {
      success: true,
      outputBase64: data.processedImageUrl,
    };
  },
  gemini: async (chat) => {
    const apikeyArray = [
      "AIzaSyAsK1wvpBD4I1DAl7_2dKk3vTqT0TeFDxg",
      "AIzaSyD8gIZEeKS_L-gYa_4f8SJxBAEAYsdC_8w",
      "AIzaSyBLMk3NPiPYXqWSujAX9mXKwIgatRfcb6g",
    ];
    const randomMath = MathRandoms(apikeyArray);
    const payload = {
      contents: [
        {
          parts: [
            {
              text: chat,
            },
          ],
        },
      ],
    };
    const { data } = await axios.post(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${randomMath}`,
      payload,
    );
    return {
      success: true,
      response: data.candidates[0].content.parts[0].text,
    };
  },
  phindChat: async (chat, options = {}) => {
    const endpoint = "https://https.extension.phind.com/agent/";

    const getHeaders = () => ({
      "Content-Type": "application/json",
      "User-Agent": "",
      Accept: "*/*",
      "Accept-Encoding": "Identity",
    });

    const createRequestBody = (input, options = {}) => ({
      additional_extension_context: "",
      allow_magic_buttons: true,
      is_vscode_extension: true,
      message_history: [
        ...(options.previousMessages || []),
        { content: input, role: "user" },
      ],
      requested_model: options.model || "Phind-70B",
      user_input: input,
    });
    try {
      const response = await fetch(endpoint, {
        method: "POST",
        headers: getHeaders(),
        body: JSON.stringify(createRequestBody(chat, options)),
      });

      if (!response.ok) {
        throw new Error(`Request failed with status ${response.status}`);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let fullText = "";

      while (true) {
        const { done, value } = await reader.read();

        if (done) {
          break;
        }

        const text = decoder.decode(value);
        const lines = text.split("\n");

        for (const line of lines) {
          if (line.startsWith("data: ")) {
            try {
              const jsonStr = line.slice(6);
              if (jsonStr === "[DONE]") continue;

              const data = JSON.parse(jsonStr);
              if (data.choices?.[0]?.delta?.content) {
                fullText += data.choices[0].delta.content;
              }
            } catch (e) {
              // Skip invalid JSON
            }
          }
        }
      }

      return fullText;
    } catch (error) {
      console.error("Error:", error);
      throw error;
    }
  },
  ratePhoto: async (url) => {
    const ress = await axios.get(url, {
      responseType: "arraybuffer",
    });
    const binarys = Buffer.from(ress.data, "binary");
    const d = new FormDatas();
    d.append("imageFile", binarys, { filename: "y.png" });
    d.append("canvasimg", "");
    d.append(
      "image_data",
      `data:image/png;base64,${Buffer.from(ress.data).toString("base64")}`,
    );
    const headers = {
      headers: {
        ...d.getHeaders(),
      },
    };
    const { data: s } = await axios.post(
      "https://rate-my-photo.com/result",
      d,
      headers,
    );
    const $ = cheerio.load(s);
    const score = $(".skill-progress")
      .first()
      .text()
      .trim()
      .replace("SCORE: ", "");
    const compare = $(".card-text").text().trim();
    const aesthetic = $(".text-success").text().replace(/\s+/g, " ").trim();
    return {
      success: true,
      result: {
        score,
        aesthetic,
      },
    };
  },
  img2prompt: async (u) => {
    if (!u) throw new Error("Masukkan URL-nya");

    const rdss = await axios.get(u, { responseType: "arraybuffer" });

    const form = new FormDatas();
    form.append("image_bytes", rdss.data, { filename: "image.png" });

    const { data } = await axios({
      method: "post",
      url: "https://api.findit.moe/util/image_caption",
      data: form,
      headers: form.getHeaders(),
      responseType: "stream",
    });

    return new Promise((resolve, reject) => {
      function parsePromptText(text) {
        const extract = (tag) => {
          const regex = new RegExp(
            `<${tag}>\\s*([\\s\\S]*?)\\s*</${tag}>`,
            "i",
          );
          const match = text.match(regex);
          return match ? match[1].trim() : "";
        };

        return {
          description: extract("DESCRIPTION"),
          details: extract("DETAILS"),
          style: extract("STYLE"),
          query: extract("QUERY"),
        };
      }
      let fullText = "";

      data.on("data", (chunk) => {
        try {
          const lines = chunk.toString().split("\n");
          for (const line of lines) {
            if (line.startsWith("data:")) {
              const payload = JSON.parse(line.replace(/^data:\s*/, ""));
              fullText += payload.content || "";
            }
          }
        } catch (err) {
          console.error("Parsing error:", err);
        }
      });

      data.on("end", () => {
        resolve(parsePromptText(fullText));
      });

      data.on("error", reject);
    });
  },
  pollai: async (
    question,
    {
      systemMessage = "yang membuatmu adalah suzakuTeam dan owner mu cifumo",
      model = "gpt-4.1-mini",
      imageBuffer = null,
    } = {},
  ) => {
    try {
      const modelList = {
        "gpt-4.1": "openai-large",
        "gpt-4.1-mini": "openai",
        "gpt-4.1-nano": "openai-fast",
      };

      if (!question) throw new Error("Question is required");
      if (!modelList[model])
        throw new Error(
          `List available model: ${Object.keys(modelList).join(", ")}`,
        );

      const messages = [
        ...(systemMessage ? [{ role: "system", content: systemMessage }] : []),
        {
          role: "user",
          content: [
            { type: "text", text: question },
            ...(imageBuffer
              ? [
                  {
                    type: "image_url",
                    image_url: {
                      url: `data:image/jpeg;base64,${imageBuffer.toString("base64")}`,
                    },
                  },
                ]
              : []),
          ],
        },
      ];

      const { data } = await axios.post(
        "https://text.pollinations.ai/openai",
        {
          messages,
          model: modelList[model],
          temperature: 0.5,
          presence_penalty: 0,
          top_p: 1,
          frequency_penalty: 0,
        },
        {
          headers: {
            accept: "*/*",
            authorization: "Bearer dummy",
            "content-type": "application/json",
            origin: "https://sur.pollinations.ai",
            referer: "https://sur.pollinations.ai/",
            "user-agent":
              "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36",
          },
        },
      );

      return data.choices[0].message.content;
    } catch (error) {
      console.error(error.message);
      throw new Error("No result found");
    }
  },
  claila: async (msg, sessionid, model) => {
    const validModels = [
      "chatgpt",
      "grok",
      "chatgpto1p",
      "claude",
      "chatgpt41mini",
      "gemini",
      "mistral",
    ];

    if (!validModels.includes(model)) {
      throw new Error(
        `Model tidak valid. Pilihan yang tersedia: ${validModels.join(", ")}`,
      );
    }

    let csrfToken;

    try {
      const tokenres = await axios.get(
        "https://app.claila.com/api/v2/getcsrftoken",
      );

      if (tokenres.status === 403) {
        throw new Error("dapet hadiah tuh bang 403");
      }

      csrfToken = tokenres.data;
      if (!csrfToken)
        throw new Error("Token kosong, mungkin format response berubah?");
    } catch (err) {
      if (err.message === "403" || err.response?.status === 403) {
        return {
          status: false,
          msg: "ngambil tokennya gabisa rek, itu vps mu jelek kayaknya, ganti region makanya jangan sg terus wkwk",
        };
      }
      return {
        status: false,
        msg: "servernya lagi down atau webnya nambah bypass lagi kayaknya om sabar yah wkwkw",
      };
    }

    try {
      const datas = new URLSearchParams({
        calltype: "completion",
        message: msg,
        sessionId: sessionid,
      });
      const data = datas.toString();

      const response = await axios.post(
        `https://app.claila.com/api/v2/unichat1/${model}`,
        data,
        {
          headers: {
            "User-Agent":
              "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Mobile Safari/537.36",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Content-Type": "application/x-www-form-urlencoded",
            "sec-ch-ua-platform": '"Android"',
            "x-csrf-token": csrfToken,
            "sec-ch-ua":
              '"Google Chrome";v="137", "Chromium";v="137", "Not/A)Brand";v="24"',
            "sec-ch-ua-mobile": "?1",
            "x-requested-with": "XMLHttpRequest",
            origin: "https://app.claila.com",
            "sec-fetch-site": "same-origin",
            "sec-fetch-mode": "cors",
            "sec-fetch-dest": "empty",
            referer: "https://app.claila.com/chat?uid=9683c3b4&lang=en",
            "accept-language": "en-GB,en;q=0.9,id;q=0.8,en-US;q=0.7,ja;q=0.6",
            priority: "u=1, i",
          },
        },
      );

      return {
        status: true,
        msg: response.data,
      };
    } catch (e) {
      if (e.response?.status === 403 || e.message.includes("403")) {
        return {
          status: false,
          msg: "vps mu jelek tuh dapet 403, ganti region aja lek",
        };
      } else {
        return {
          status: false,
          msg: "scrapenya rusak kali om, tanyain sama yang punya aja",
        };
      }
    }
  },
  ripleAI: async (text) => {
    let payload = {
      messages: [
        {
          content: text,
          role: "user",
        },
      ],
    };

    try {
      let { data } = await axios.post("https://ai.riple.org/", payload, {
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        },
        responseType: "stream",
      });

      return new Promise((resolve, reject) => {
        let fullResponse = "";

        data.on("data", (chunk) => {
          let lines = chunk.toString().split("\n");

          for (let line of lines) {
            if (line.startsWith("data: ")) {
              let jsonString = line.slice(6).trim();

              if (jsonString === "[DONE]") {
                return resolve({ result: fullResponse.trim() });
              }

              try {
                let parsedData = JSON.parse(jsonString);
                let content = parsedData?.choices?.[0]?.delta?.content;

                if (content) {
                  fullResponse += content;
                }
              } catch (err) {
                reject(err);
              }
            }
          }
        });

        data.on("error", (err) => reject(err));
      });
    } catch (error) {
      throw new Error(error.message);
    }
  },
  text2image: async (prompt) => {
    const payload = {
      clip_skip: 2,
      guidance: 7,
      height: 768,
      lora_ids: "",
      lora_weight: "0.7",
      model_id: "mistoonJade_v10Anime",
      negative_prompt: "",
      prompt,
      sampler: "Euler a",
      samples: 1,
      seed: 0,
      steps: 25,
      width: 512,
    };

    const createRes = await axios.post(
      "https://api.arting.ai/api/cg/text-to-image/create",
      payload,
    );
    const requestId = createRes.data.data.request_id;

    const checkPayload = { request_id: requestId };
    while (true) {
      const { data } = await axios.post(
        "https://api.arting.ai/api/cg/text-to-image/get",
        checkPayload,
      );
      if (data?.data?.output?.length > 0) {
        return new Success({
          imageGenerated: data.data.output[0],
        });
      }
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }
  },
  /**
   * @credit {<https://whatsapp.com/channel/0029Vb5blhMEawdx2QFALZ1D/309>}
   */
  faceswap: async (sourceUrl, targetUrl) => {
    const getBuffer = async (url) =>
      (await axios.get(url, { responseType: "arraybuffer" })).data;

    const randomName = () =>
      `FaceSwap_${Math.random().toString(36).substring(2, 10)}.jpg`;

    try {
      const sourceImg = await getBuffer(sourceUrl);
      const targetImg = await getBuffer(targetUrl);

      const form = new FormData();
      form.append("source_image", sourceImg, randomName());
      form.append("target_image", targetImg, randomName());

      const jantung = {
        ...form.getHeaders(),
        accept: "application/json",
        Referer: "https://lovefaceswap.com/",
      };

      const createRes = await axios.post(
        "https://api.lovefaceswap.com/api/face-swap/create-poll",
        form,
        { headers: jantung },
      );

      const jobId = createRes.data?.data?.task_id;
      if (!jobId) throw new Error("Job ID not found");

      const start = Date.now();
      const maxTime = 300000;

      while (Date.now() - start < maxTime) {
        const statusRes = await axios.get(
          `https://api.lovefaceswap.com/api/face-swap/get?job_id=${jobId}`,
          { headers: jantung },
        );

        const code = statusRes.data?.code;
        if (code === 200) {
          const url = statusRes.data?.data?.image_url?.[0];
          const duration = ((Date.now() - start) / 1000).toFixed(2);
          return new Success({
            image: url,
            job_id: jobId,
            duration: `${duration}s`,
          });
        }

        if (code !== 202) {
          throw new Error(
            "Unexpected response: " + JSON.stringify(statusRes.data),
          );
        }

        await new Promise((r) => setTimeout(r, 2000));
      }

      return JSON.stringify(
        {
          status: false,
          job_id: jobId,
          message:
            "Task did not finish within 5 minutes, kurang ganteng, bray.",
        },
        null,
        2,
      );
    } catch (e) {
      const detail = e.response?.data || e.message;
      return "error: " + JSON.stringify(detail, null, 2);
    }
  },
  lyricsGenerator: async (topic, style) => {
    if (!topic)
      return new ErrorResponse({ message: "Please input a topic for lyrics" });
    if (!style)
      return new ErrorResponse({ message: "Please input a style of lyrics" });

    const jar = new tough.CookieJar();
    const client = wrapper(axios.create({ jar, withCredentials: true }));

    const enc = encodeURIComponent(topic);
    const encd = encodeURIComponent(style);

    await client.get("https://boredhumans.com/lyrics_generator.php", {
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0",
        Accept: "text/html,application/xhtml+xml",
        "Accept-Language": "en-US,en;q=0.9",
        Referer: "https://boredhumans.com/",
      },
    });

    const d = new FormDatas();
    d.append("topic", enc);
    d.append("style", encd);

    const headers = {
      ...d.getHeaders(),
      "User-Agent":
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0",
      Referer: "https://boredhumans.com/",
      Origin: "https://boredhumans.com",
    };

    try {
      const { data } = await client.post(
        "https://boredhumans.com/apis/lyrics1_api.php",
        d,
        { headers },
      );
      const arrayOutput = data.output.flat();
      const outputOneString = arrayOutput.join("\n");
      return {
        success: true,
        output: outputOneString,
      };
    } catch (err) {
      return new ErrorResponse({
        message: "Failed to fetch lyrics",
        errorsMessage: err.message,
      });
    }
  },
  githubRoast: async (username, language) => {
     const jar = new tough.CookieJar()
     const client = wrapper(axios.create({
       jar,
       withCredentials: true,
       headers: {
          "Content-Type": "application/json"
       }
     }))
     await client.get("https://github-roast.pages.dev/")
     
     const payload = {
       language: language,
       username: username
     }
     const { data } = await client.post("https://github-roast.pages.dev/llama", payload)
     return new Success(data)
  }
};

module.exports = ai;
