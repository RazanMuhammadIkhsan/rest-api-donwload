import axios from "axios";
import * as cheerio from "cheerio";
import FormData from "form-data";
import { Success, ErrorResponse } from "./lib/function.js";
import generateRandomUserAgent from "./lib/userAgent.js";

const stalker = {
  mobilelegends: async (id, zoneId) => {
    async function getToken(url) {
      try {
        const response = await axios.get(url);
        const cookies = response.headers["set-cookie"];
        const joinedCookies = cookies ? cookies.join("; ") : null;

        const csrfTokenMatch = response.data.match(
          /<meta name="csrf-token" content="(.*?)">/,
        );
        const csrfToken = csrfTokenMatch ? csrfTokenMatch[1] : null;

        if (!csrfToken || !joinedCookies) {
          throw new Error("Gagal mendapatkan CSRF token atau cookie.");
        }

        return {
          csrfToken,
          joinedCookies,
        };
      } catch (error) {
        console.error(
          "申申 Error fetching cookies or CSRF token:",
          error.message,
        );
        throw error;
      }
    }
    try {
      const { csrfToken, joinedCookies } = await getToken(
        "https://www.gempaytopup.com",
      );
      if (!id || !zoneId)
        return {
          message: "Masukkan Id User Atau Zone ID",
        };

      const payload = {
        uid: id,
        zone: zoneId,
      };

      const { data } = await axios.post(
        "https://www.gempaytopup.com/stalk-ml",
        payload,
        {
          headers: {
            "X-CSRF-Token": csrfToken,
            "Content-Type": "application/json",
            Cookie: joinedCookies,
          },
        },
      );

      return data;
    } catch (error) {
      console.error("申申 Error:", error.message);
      console.error("Response:", error.response?.data || "No response data");
    }
  },
  freefire: async (id) => {
    if (!id) throw new Error("User ID tidak ditemukan");

    try {
      const payload = {
        campaignUrl: "",
        catalogId: 68,
        gameId: id,
        itemId: 13,
        paymentId: 752,
        productId: 3,
        product_ref: "REG",
        product_ref_denom: "REG",
      };

      const url =
        "https://api.duniagames.co.id/api/transaction/v1/top-up/inquiry/store";

      const { data } = await axios.post(url, payload);

      const gameDetail = {
        id,
        userName: data?.data?.gameDetail?.userName || "Unknown",
      };

      return gameDetail;
    } catch (error) {
      console.error("Error:", error.message);
      return [];
    }
  },
  genshin: async (uid) => {
    try {
      const { data } = await axios.get(`https://enka.network/u/${uid}/`);
      const $ = cheerio.load(data);

      const nickname = $(".PlayerInfo h1").text().trim();
      const arText = $(".PlayerInfo .ar").text().trim();
      const [ar, wl] = arText.match(/\d+/g) || ["?", "?"];
      const signature = $(".PlayerInfo .signature").text().trim();

      const achievements = $(".stats .stat")
        .eq(0)
        .find("td")
        .first()
        .text()
        .trim();
      const abyss = $(".stats .stat").eq(1).find("td").first().text().trim();

      const characters = [];
      $(".CharacterList .avatar").each((i, el) => {
        const style = $(el).find("figure").attr("style");
        const level = $(el).find(".level").text().trim();

        const nameMatch = style?.match(/\/UI_AvatarIcon_Side_(.+?)\.png/);
        if (nameMatch) {
          const rawName = nameMatch[1];
          characters.push({
            name: rawName.replace(/Costume.+$/, ""),
            level,
          });
        }
      });

      return {
        uid,
        nickname,
        ar,
        wl,
        bio: signature,
        achievementsPoint: achievements,
        abyss,
        characters,
      };
    } catch (err) {
      return { error: `Gagal mengambil data UID ${uid}: ${err.message}` };
    }
  },
  telegram: async (usn) => {
    try {
      const { data } = await axios.get(`https://t.me/${usn}`);
      const $ = cheerio.load(data);

      const photo = $(".tgme_page_photo_image").attr("src") || null;
      const name = $(".tgme_page_title > span").text().trim() || null;
      const username = $(".tgme_page_extra").text().trim() || null;

      return {
        name,
        username,
        photo,
      };
    } catch (err) {
      return {
        error: true,
        message:
          "Gagal mengambil data Telegram. Mungkin usernamenya salah atau private.",
      };
    }
  },
  roblox: async (name) => {
    try {
      const fetchJson = async (url, options) => {
        return (await fetch(url, options)).json();
      };

      const getUsernameData = async () => {
        return fetchJson("https://users.roblox.com/v1/usernames/users", {
          method: "POST",
          body: JSON.stringify({ usernames: [name] }),
          headers: { "Content-Type": "application/json" },
        });
      };

      const getUserData = async (id) => {
        return fetchJson("https://users.roblox.com/v1/users/" + id);
      };

      const getProfile = async (id) => {
        return fetchJson(
          "https://thumbnails.roblox.com/v1/users/avatar?userIds=" +
            id +
            "&size=720x720&format=Png&isCircular=false",
        );
      };

      const getPresenceData = async (id) => {
        return fetchJson("https://presence.roblox.com/v1/presence/users", {
          method: "POST",
          body: JSON.stringify({ userIds: [parseInt(id)] }),
          headers: { "Content-Type": "application/json" },
        });
      };

      const { data } = await getUsernameData();

      if (!data || data.length === 0) {
        return { status: false, message: "Username not found" };
      }

      const id = data[0].id;

      const userDetails = await getUserData(id);
      const profileDetails = (await getProfile(id)).data[0].imageUrl;
      const lastOnline =
        (await getPresenceData(id)).userPresences[0]?.lastOnline || "N/A";

      const result = {
        basicInfo: {
          description: userDetails.description || "",
          created: userDetails.created,
          isBanned: userDetails.isBanned,
          externalAppDisplayName: userDetails.externalAppDisplayName,
          hasVerifiedBadge: userDetails.hasVerifiedBadge,
          id: userDetails.id,
          name: userDetails.name,
          displayName: userDetails.displayName,
        },
        lastOnline: lastOnline,
        profileDetails: profileDetails,
      };
      return new Success(result);
    } catch (error) {
      return new ErrorResponse(error);
    }
  },
  github: async (usn) => {
    try {
      const { data } = await axios.get(`https://api.github.com/users/${usn}`);
      return new Success(data);
    } catch (errorRequestCallBack) {
      return new ErrorResponse(errorRequestCallBack);
    }
  },
  instagram: async (usr) => {
    const { data } = await axios.get(
      `https://content.mollygram.com/?url=${usr}`,
    );
    const $ = cheerio.load(data.html);

    const usernameEl = $("h4.mb-0");
    const username = usernameEl.text().trim().split(/\s/)[0];
    const isVerified = usernameEl.find("i.fas.fa-check-circle").length > 0;

    const name = $("p.text-muted").text().trim();
    const bio = $("p.text-dark").first().text().trim();
    const profilePic = $("img.rounded-circle").attr("src");

    const stats = $("div.d-flex.justify-content-around.text-center.mt-3 > div");
    const posts = $(stats[0]).find("span").text().trim();
    const followers = $(stats[2]).find("span").text().trim();
    const following = $(stats[1]).find("span").text().trim();

    const ress = {
      username,
      name,
      bio,
      profilePic,
      posts,
      followers,
      following,
      isVerified,
    };
    return new Success(ress);
  },
};

export default stalker;
